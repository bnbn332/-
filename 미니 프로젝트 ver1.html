<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>영상 처리</title>

    <style>
         #photoReturn{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            border: 1px solid rgb(136, 133, 164);
            background-color: rgba(0, 0, 0, 0);
            color: rgb(136, 133, 164);
            padding: 5px;
        }

        #photoReturn2{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            border: 1px solid rgb(136, 133, 164);
            background-color: rgba(0, 0, 0, 0);
            color: rgb(136, 133, 164);
            padding: 5px;
        }

        #select{
            margin: auto;
            width: 81%;
        }


        #photoReturn:hover{
            color:white;
            background-color: rgb(136, 133, 164);
        }

        #photoReturn2:hover{
            color:white;
            background-color: #61506C;
        }

        #photoAdd{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;


        }
        #photoBW{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoAvgBW{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoZoomOut{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoZoomIn{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoRotate1{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoRotate2{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoMove{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoLnR{
            bottom: 10px;
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #photoUnD{
            bottom: 10px;
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #btn_group button{
            border: 1px solid #985f99;
            background-color: rgba(0, 0, 0, 0);
            color: #9684A1;
            padding: 5px;
        }

        #btn_group button:hover{
            color:white;
            background-color: #985f99;
        }

        #btn_group2 button{
            border: 1px solid #9684A1;
            background-color: rgba(0, 0, 0, 0);
            color: #AAACB0;
            padding: 5px;
        }

        #btn_group2 button:hover{
            color:white;
            background-color: #9684A1;
        }

        #btn_group3 button{
            border: 1px solid #9684A1;
            background-color: rgba(0, 0, 0, 0);
            color: #AAACB0;
            padding: 5px;
        }

        #btn_group3 button:hover{
            color:white;
            background-color: #9684A1;
        }

        #btn_group4 button{
            border: 1px solid #AAACB0;
            background-color: rgba(0, 0, 0, 0);
            color: #B6C9BB;
            padding: 5px;
        }

        #btn_group4 button:hover{
            color:white;
            background-color: #AAACB0;
        }

        #btn_group5 button{
            border: 1px solid #B6C9BB;
            background-color: rgba(0, 0, 0, 0);
            color: #B6C9BB;
            padding: 5px;
        }

        #btn_group5 button:hover{
            color:white;
            background-color: #B6C9BB;
        }

        #btn_group6 button{
            border: 1px solid #D0F0C0;
            background-color: rgba(0, 0, 0, 0);
            color: #B6C9BB;
            padding: 5px;
        }

        #btn_group6 button:hover{
            color:white;
            background-color: #D0F0C0;
        }

        #sf1{
            border: 1px solid #61506C;
            background-color: rgb(136, 133, 164);
            color:white;
            padding: 5px;
        }

        #sf2{
            border: 1px solid rgb(136, 133, 164);
            background-color: #61506C;
            color: white;
            padding: 5px;
        }





        #selectFile{
            padding:6px 25px;
            background-color: rgb(136, 133, 164);
            border-radius: 4px;
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            color: white;
            cursor: pointer
        }

        #selectFile2{
            padding:6px 25px;
            background-color: #61506C;
            border-radius: 4px;
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            color: white;
            cursor: pointer
        }

        #photoStratch{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoEndIn{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoSmooth{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoEmboss{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoBlurr{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoGausian{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }
        #photoSharp1{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }
        #photoSharp2{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }
        #photoSharpHigh{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }
        #photoSharpLow{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }
        #photoPrewitt{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }
        #photoSobel{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoChange{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoOrange{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoRed{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoBlue{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoGreen{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoPurple{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #photoYello{
            border-top-left-radius: 10px;
            border-top-right-radius:  10px;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;

        }

        #h4_1{
            background-color:#985f99;
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }

        #h4_2{
            background-color:#9684A1;
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }

        #h4_3{
            background-color: #AAACB0;
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }

        #h4_4{
            background-color: #B6C9BB;
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }

        #h4_5{
            background-color: #D0F0C0;
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }

        #h4_6{
            background-color: #E3F97B;
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }

        #h4_7{
            background-color: rgb(135, 178, 235);
            color : white;
            text-align: center;
            margin-left: 0px;
            margin-right: 0px;
        }


    </style>




    <script>
        // 전역 변수(*중요*)
        var inCanvas, inCtx, outCanvas, outCtx;  // 입력 캔버스 관련
        var inFile, inImageArray, outImageArray;  // 입력 파일 및 배열
        var inWidth, inHeight, outWidth, outHeight;  // 입력 영상의 폭과 높이
        var inPaper, outPaper; // 캔버스에는 한점한점이 안찍힘. 대신 캔버스에 종이를 붙임.
        function init() {
            inCanvas = document.getElementById('inCanvas');
            inCtx = inCanvas.getContext('2d');
            outCanvas = document.getElementById('outCanvas');
            outCtx = outCanvas.getContext('2d');
        }

        function readRawImage() { //raw 파일용
            inFile = document.getElementById('selectFile').files[0];
            // 중요! 코드 (영상의 크기를 파악)
            inWidth = inHeight = Math.sqrt(inFile.size);
            // 입력 2차원 배열을 준비
            inImageArray = new Array(inHeight); // 256짜리 1차원 배열
            for(var i=0; i<inHeight; i++) 
                inImageArray[i] = new Array(inWidth);
            // 캔버스 크기를 결정
            inCanvas.width = inWidth;
            inCanvas.height = inHeight;
            // RAW 파일  --> 2차원 배열
            var reader = new FileReader();
            reader.readAsBinaryString(inFile);
            reader.onload = function () {
                var bin = reader.result; // 파일을 덩어리(bin)로 읽었음
                // 덩어리(bin)에서 한점한점씩 뽑아서, 배열에 넣기
                for(var i=0; i<inHeight; i++) {
                    for(var k=0; k<inWidth; k++) {
                        // 0,0  0,1  0,2 ...... 0,255
                        // 1,0  1,1, 1,2 .......1,255
                        // ....
                        // 255,0  255,1 ....... 255,255
                        var sPixel = (i * inHeight + k);
                        var ePixel = (i * inHeight + k) + 1;
                        inImageArray[i][k] = bin.slice(sPixel,ePixel); // 1개픽셀-->배열
                    }
                }
                // 화면에 출력하기 (사람용)
                inPaper = inCtx.createImageData(inHeight, inWidth); //종이 붙였음.
                for(var i=0; i<inHeight; i++) {
                    for (var k=0; k<inWidth; k++) {
                        var charValue = inImageArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                        inPaper.data[(i*inWidth + k) * 4 + 0] = charValue; // R
                        inPaper.data[(i*inWidth + k) * 4 + 1] = charValue; // G
                        inPaper.data[(i*inWidth + k) * 4 + 2] = charValue; // B
                        inPaper.data[(i*inWidth + k) * 4 + 3] = 255; // Alpha
                    }
                }
                inCtx.putImageData(inPaper,0,0);

            }

        }   
        
        function openImage() { //컬러이미지용
            inFile = document.getElementById('selectFile2').files[0];
            // 그림파일 --> 이미지 객체
            var inImage = new Image(); // 빈 이미지 객체 생성
            inImage.src = inFile.name;

            inImage.onload = function() {
                // 입력 파일의 크기를 알아냄 (중요!)
                inWidth = inImage.width;
                inHeight = inImage.height;
                // 캔버스 크기를 결정
                inCanvas.width = inWidth;
                inCanvas.height = inHeight;
                inCtx.drawImage(inImage,0,0,inWidth, inHeight);
                // 입력 3차원 배열을 준비
                inImageArray = new Array(3); // 3장짜리 배열 (R, G, B)
                for(var i=0; i<3; i++) {
                    inImageArray[i] = new Array(inHeight);
                    for(var k=0; k<inHeight; k++)
                        inImageArray[i][k] = new Array(inWidth);
                }
                // 출력된 캔버스에서 픽셀값 뽑기
                var imageData = inCtx.getImageData(0,0,inWidth, inHeight);
                var R,G,B,Alpha;
                for (var i=0; i<inHeight; i++) {
                    for(var k=0; k<inWidth; k++) {
                        px = (i * inWidth + k) * 4; // 1픽셀 = 4byte
                        R = imageData.data[px + 0];
                        G = imageData.data[px + 1];
                        B = imageData.data[px + 2];
                        // Alpha = imageData.data[px + 3];
                        inImageArray[0][i][k] = String.fromCharCode(R);
                        inImageArray[1][i][k] = String.fromCharCode(G);
                        inImageArray[2][i][k] = String.fromCharCode(B);
                    }
                }
            }           

        }        
        ///////  영상 처리 함수 모음 //////////
        function displayImage() {
            // 캔버스 크기를 결정
            outCanvas.height = outHeight;
            outCanvas.width = outWidth;

            var R, G, B;
            outPaper = outCtx.createImageData(outWidth, outHeight);
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    R = outImageArray[0][i][k].charCodeAt(0); // Byte 문자를 숫자로.
                    G = outImageArray[1][i][k].charCodeAt(0); // Byte 문자를 숫자로.
                    B = outImageArray[2][i][k].charCodeAt(0); // Byte 문자를 숫자로.
                    outPaper.data[(i*outWidth + k) * 4 + 0] = R;
                    outPaper.data[(i*outWidth + k) * 4 + 1] = G;
                    outPaper.data[(i*outWidth + k) * 4 + 2] = B;
                    outPaper.data[(i*outWidth + k) * 4 + 3] = 255;
                }
            }
            outCtx.putImageData(outPaper, 0, 0);
        }
        
///////  영상 처리 함수 모음 //////////
        function returnImage(){
            // 출력영상크기결정
            outwidth = inWidth;
            outheight = inHeight;

            //출력 2차원 배열준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    outImageArray[i][k] = inImageArray[i][k]
                }
            }
          printOutImage();
        }

        function printOutImage() {
              // 캔버스 크기를 결정
            outCanvas.width = outWidth;
            outCanvas.height = outHeight;
            outPaper = outCtx.createImageData(outHeight, outWidth); //종이 붙였음.
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    var charValue = outImageArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                    outPaper.data[(i*outWidth + k) * 4 + 0] = charValue; // R
                    outPaper.data[(i*outWidth + k) * 4 + 1] = charValue; // G
                    outPaper.data[(i*outWidth + k) * 4 + 2] = charValue; // B
                    outPaper.data[(i*outWidth + k) * 4 + 3] = 255; // Alpha
                }
            }
            outCtx.putImageData(outPaper,0,0);
        }


        function addImage() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseInt(prompt("밝게할 값", "0"));
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    pixel = inImageArray[i][k].charCodeAt(0);
                    // **** 핵심 알고리즘. (밝게하기)
                    if (pixel + value > 255)
                        pixel = 255;
                    else 
                        pixel += value;
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
          printOutImage();
        }

        function bwImage() {  // 흑백 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseInt(prompt("기준 값", "127"));
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    pixel = inImageArray[i][k].charCodeAt(0);
                    // **** 핵심 알고리즘(흑백)
                    if (pixel > value)
                        pixel = 255;
                    else   
                        pixel = 0;
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
          printOutImage();
        }

        function bwAvgImage() {  // 흑백 알고리즘(평균값)
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            var hap = 0;
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) 
                    hap += inImageArray[i][k].charCodeAt(0);
            var value = hap / (inHeight*inWidth) ;
            
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    pixel = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘. (흑백)
                    if (pixel > value)
                        pixel = 255;
                    else   
                        pixel = 0;
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
          printOutImage();
        }

        function zoomOutImage() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            var scale = parseInt(prompt("축소 배율(짝수)", "2"));
            outHeight = parseInt(inHeight/scale);//출력 세로길이
            outWidth = parseInt(inWidth/scale);// 출력 가로길이
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****

            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // **** 핵심 알고리즘. (영상축소)
                    outImageArray[parseInt(i/scale)][parseInt(k/scale)] = inImageArray[i][k];
                }
            }
          printOutImage();
        }

        function zoomInImage() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            var scale = parseInt(prompt("확대 배율(짝수)", "2"));
            outHeight = parseInt(inHeight*scale);
            outWidth = parseInt(inWidth*scale);
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            //outImageArray를 초기화 시키기(0으로 채우기)
            for(var i=0; i<outHeight; i++){
                for (var k=0; k<outWidth; k++) {
                    outImageArray[i][k] = String.fromCharCode(0);}
                }

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    // **** 요기가 핵심 알고리즘. (영상확대)
                    outImageArray[i][k] = inImageArray[parseInt(i/scale)][parseInt(k/scale)];
                }
            }
          printOutImage();
        }

        function rotate1Image() { //회전 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            var degree = parseFloat(prompt("회전각도", 45));
            var radian = degree * Math.PI / 180.0; // degree->radian
            
            // xd = cos * xs - sin * ys;
            // yd = sin * xs + cos * ys;
            var xd, yd, xs, ys;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = parseInt(Math.cos(radian) * xs - Math.sin(radian) * ys);
                    yd = parseInt(Math.sin(radian) * xs + Math.cos(radian) * ys);

                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xd][yd] = inImageArray[xs][ys];
                }
            }
            printOutImage();

        }

        function rotate2Image(){
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            var degree = parseFloat(prompt("회전각도", 45));
            var radian = degree * Math.PI / 180.0; // degree->radian
            radian = -radian;
            // xd = cos * xs - sin * ys;
            // yd = sin * xs + cos * ys;
            var xd, yd, xs, ys;
            var cx = parseInt(inHeight/2); //x중앙값
            var cy = parseInt(inWidth/2);  //y중앙값
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = parseInt(Math.cos(radian) * (xs-cx) - Math.sin(radian) * (ys-cy)+cx);
                    yd = parseInt(Math.sin(radian) * (xs-cx) + Math.cos(radian) * (ys-cy)+cy);

                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xs][ys] = inImageArray[xd][yd];
                    else
                        outImageArray[xs][ys] = String.fromCharCode(255);
                }
            }
            printOutImage();
        }

        function stratchImage(){
            //출력영상크기
            outHeight = inHeight;
            outWidth = inWidth;
            //출력 2차원 배열
            outImageArray = new Array(outHeight);
            for(var i=0; i<outHeight; i++)
                outImageArray[i] = new Array(outWidth);

            //out = (in - low)/(high - low) * 255 기본 명암 대비 스트레칭 수행 공식
            var low = inImageArray[0][0].charCodeAt(0); //히스토그램의 최저 명도 값
            var high = inImageArray[0][0].charCodeAt(0); //히스토그램의 최고 명도 값
            for(var i=0; i<inHeight; i++){
                for(var k=0; k<inWidth; k++){
                    pixel=inImageArray[i][k].charCodeAt(0);
                    if(pixel < low)
                        low = pixel;    //히스토그램의 최저 명도 값
                    if(pixel > high)
                        high = pixel;   //히스토그램의 최고 명도 값
                }
            }

            for(var i=0; i<inHeight; i++){
                for(var k=0; k<inWidth; k++){
                    inValue = inImageArray[i][k].charCodeAt(0);
                    outValue = (inValue - low)/(high - low) *255;   //수행 공식
                    outImageArray[i][k] = String.fromCharCode(outValue);
                }
            }
            printOutImage();
        }

        function endInImage(){
            //출력영상크기
            outHeight = inHeight;
            outWidth = inWidth;
            //출력 2차원 배열
            outImageArray = new Array(outHeight);
            for(var i=0; i<outHeight; i++)
                outImageArray[i] = new Array(outWidth);

            //out = (in - low)/(high - low) * 255 기본 명암 대비 스트레칭 수행 공식
            var low = inImageArray[0][0].charCodeAt(0); //히스토그램의 최저 명도 값
            var high = inImageArray[0][0].charCodeAt(0); //히스토그램의 최고 명도 값
            for(var i=0; i<inHeight; i++){
                for(var k=0; k<inWidth; k++){
                    pixel=inImageArray[i][k].charCodeAt(0);
                    if(pixel < low)
                        low = pixel;    //히스토그램의 최저 명도 값
                    if(pixel > high)
                        high = pixel;   //히스토그램의 최고 명도 값
                }
            }

            low +=50;
            high -=50;

            for(var i=0; i<inHeight; i++){
                for(var k=0; k<inWidth; k++){
                    inValue = inImageArray[i][k].charCodeAt(0);
                    outValue = (inValue - low)/(high - low) *255;   //수행 공식
                    if(outValue > 255)
                        outValue = 255;
                    else if(outValue < 0)
                        outValue = 0;
                    outImageArray[i][k] = String.fromCharCode(outValue);
                }
            }
            printOutImage();
        }

        function smoothImage(){
                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    // 1단계 : 히스토그램 생성
                    histo = new Array(256);  
                    for (var i=0; i<256; i++) //초기화
                        histo[i] = 0;
                    for(var i=0; i<inHeight; i++) 
                        for (var k=0; k<inWidth; k++) {
                            value = inImageArray[i][k].charCodeAt(0);
                            histo[value] ++;
                        }
                    // 2단계 : 누적 히스토그램 생성
                    sumHisto = new Array(256);  
                    for (var i=0; i<256; i++)
                        sumHisto[i] = 0;     
                    sumVal = 0;                       
                    for (var i=0; i<256; i++) {
                        sumVal += histo[i];
                        sumHisto[i] = sumVal;
                    }
                    // 3단계 : 정규화된 누적히스토그램
                    // ns = s * (1/픽셀총수) * 화소최대밝기
                    normalHisto = new Array(256);  
                    for (var i=0; i<256; i++)
                        normalHisto[i] = 0.0; 
                    for (var i=0; i<256; i++)
                        normalHisto[i] = sumHisto[i] * ( 1 / (inWidth*inHeight)) * 255;
                        
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            inVal = inImageArray[i][k].charCodeAt(0);
                            
                            outVal = normalHisto[inVal];
                            if (outVal > 255)
                                outVal = 255;
                            else if (outVal < 0)
                                outVal = 0;
                            else 
                                outVal = parseInt(outVal);
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(outVal);
                        }
                    }
                    printOutImage();
        }

        function embossImage() {  // 엠보싱 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., 0., 0.], 
                            [  0., 0., 0.], 
                            [  0., 0., 1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function blurrImage() {  // 블러링 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function gausianImage(){ //가우시안 스무딩 필터링
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1/16., 1/8., 1/16.], 
                            [ 1/8., 1/4., 1/8.], 
                            [ 1/16., 1/8., 1/16.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function sharpImage1(){ //샤프닝 1
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., -1., -1.], 
                            [ -1., 9., -1.], 
                            [ -1., -1., -1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function sharpImage2(){ //샤프닝 2
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0., -1., 0.], 
                            [ -1., 5., -1.], 
                            [ 0., -1., 0.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function highSharpImage(){ // 고주파 샤프닝
                 // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                 outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1/9., -1/9., -1/9.], 
                            [ -1/9., 8/9., -1/9.], 
                            [ -1/9., -1/9., -1/9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function lowSharpImage(){ //샤프닝 저주파
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function preWittImage(){ //Prewitt
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., -1., -1.], 
                            [ 0., 0., 0.], 
                            [ 1., 1., 1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function sobelImage(){ //Sobel
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., -2., -1.], 
                            [ 0., 0., 0.], 
                            [ 1., 2., 1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            printOutImage();
        }

        function moveImage(){
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            var x = parseInt(prompt("세로값", 0));
            var y = parseInt(prompt("가로값", 0));
            
            var xd, yd, xs, ys;

            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = xs-x;
                    yd = ys-y;

                    // 회전 이후의 위치가 출력영상의 범위 안에 있는지 확인
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xs][ys] = inImageArray[xd][yd];
                    else
                        outImageArray[xs][ys] = String.fromCharCode(0);
                }
            }
            printOutImage();
        }

        function lnrImage(){
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            
            var xd, yd, xs, ys;

            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = xs;
                    yd = outWidth-k-1;

                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xs][ys] = inImageArray[xd][yd];
                    else
                        outImageArray[xs][ys] = String.fromCharCode(0);
                }
            }
            printOutImage();
        }
        
        function undImage(){
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            
            var xd, yd, xs, ys;

            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = outHeight-i-1;
                    yd = ys;

                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xs][ys] = inImageArray[xd][yd];
                    else
                        outImageArray[xs][ys] = String.fromCharCode(0);
                }
            }
            printOutImage();
        }
        





        //접기, 펼치기 메뉴
                
        function doDisplay1(){
            var con = document.getElementById("btn_group");
            if(con.style.display=='none'){
                con.style.display = 'block';
            }else{
                con.style.display = 'none';
            }
        }

        function doDisplay2(){
            var con = document.getElementById("btn_group2");
            if(con.style.display=='none'){
                con.style.display = 'block';
            }else{
                con.style.display = 'none';
            }
        }

        function doDisplay3(){
            var con = document.getElementById("btn_group3");
            if(con.style.display=='none'){
                con.style.display = 'block';
            }else{
                con.style.display = 'none';
            }
        }

        function doDisplay4(){
            var con = document.getElementById("btn_group4");
            if(con.style.display=='none'){
                con.style.display = 'block';
            }else{
                con.style.display = 'none';
            }
        }

        function doDisplay5(){
            var con = document.getElementById("btn_group5");
            if(con.style.display=='none'){
                con.style.display = 'block';
            }else{
                con.style.display = 'none';
            }
        }

        function doDisplay6(){
            var con = document.getElementById("btn_group6");
            if(con.style.display=='none'){
                con.style.display = 'block';
            }else{
                con.style.display = 'none';
            }
        }



        //컬러용
        function equalImage() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            for (var rgb=0; rgb<3; rgb++) {
                for(var i=0; i<inHeight; i++) {
                    for (var k=0; k<inWidth; k++) {
                        outImageArray[rgb][i][k] = inImageArray[rgb][i][k];
                    }
                }
            }
            displayImage();
        }

        function rgb2hsv(r, g, b) {
            var max = Math.max(r, g, b), min = Math.min(r, g, b),
                d = max - min,
                h,
                s = (max === 0 ? 0 : d / max),
                v = max / 255;

            switch (max) {
                case min: h = 0; break;
                case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
                case g: h = (b - r) + d * 2; h /= 6 * d; break;
                case b: h = (r - g) + d * 4; h /= 6 * d; break;
            }
            return {
                h: h,    s: s,    v: v
            };
        }

        function hsv2rgb(h, s, v) {
            var r, g, b, i, f, p, q, t;

            h = h*360;  s = s*100;    v = v*100;

            // Make sure our arguments stay in-range
            h = Math.max(0, Math.min(360, h));
            s = Math.max(0, Math.min(100, s));
            v = Math.max(0, Math.min(100, v));
            
            h /= 360;   s /= 100;     v /= 100;

            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function changeSaturation() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseFloat(prompt("채도 값", 0.2));
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;
                    
                    S += value;

                    var rgb = hsv2rgb(H, S, V)
                    var R = rgb.r;
                    var G = rgb.g;
                    var B = rgb.b;

                    outImageArray[0][i][k] = String.fromCharCode(R);
                    outImageArray[1][i][k] = String.fromCharCode(G);
                    outImageArray[2][i][k] = String.fromCharCode(B);
                }
            }
            displayImage();
        }


        function findRed() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;

                    if ( 333<(H*360) && 0<(H*390)) { //빨간 색
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    }else {
                        var RGB = parseInt((R + G + B) /3);
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }


        function findOrange() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;

                    if(  0<(H*360) && (H*390)<30) { //오렌지 색
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    }else {
                        var RGB = parseInt((R + G + B) /3);
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }


        function findYello() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;

                    if ( 45<(H*360) && (H*390)<75) { //노란 색
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    }else {
                        var RGB = parseInt((R + G + B) /3);
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }

        function findGreen() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;

                    if (63 < (H*360) && (H*390) < 155) { //초록 색
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    }else {
                        var RGB = parseInt((R + G + B) /3);
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }

        function findBlue() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;

                    if ( 210< (H*360) && (H*390) < 255) { //파란 색
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    }else {
                        var RGB = parseInt((R + G + B) /3);
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }


        function findPurple() {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;

                    if (283 < (H*360) && (H*390) < 330) { //보라 색
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    }else {
                        var RGB = parseInt((R + G + B) /3);
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }




    </script>

</head>
<body onload='init()'>
    <div id="select">
    <button id="sf1" style="position: relative; left: 570px;">Raw</button>
    <input type='file' id='selectFile' onchange='readRawImage()' style="position: relative; left: 570px;"/>   <button id="photoReturn" onclick="returnImage()" style="position: relative; left: 600px;">원래대로</button>
    <br>
    <br>
    <button id="sf2" style="position: relative; left: 570px;">컬러</button>
    <input type='file' id='selectFile2' onchange='openImage()' style="position: relative; left: 570px;"/>   <button id="photoReturn2" onclick="equalImage() "style="position: relative; left: 600px;">원래대로</button>
    </div>
    <hr>
        <h4 id="h4_1" onclick="doDisplay1()">화소점 처리 ▼[펼치기/닫기]</h4>
        <div id="btn_group" style="position: relative; left: 44%;">
        <button id="photoAdd" onclick="addImage()">밝게하기</button>
        <button id="photoBW" onclick="bwImage()">흑백처리</button>
        <button id="photoAvgBW" onclick="bwAvgImage()">흑백처리(평균)</button>
        </div>

        <h4 id="h4_2" onclick="doDisplay2()">기하학 처리 ▼[펼치기/닫기]</h4>
        <div id="btn_group2" style="position: relative; left: 700px;">
        <button id="photoZoomOut" onclick="zoomOutImage()">축소</button>
        <button id="photoZoomIn" onclick="zoomInImage()">확대</button>
        <button id="photoRotate1" onclick="rotate1Image()">회전 기본</button>
        <button id="photoRotate2" onclick="rotate2Image()">회전 백워딩.중앙</button>
        <button id="photoMove" onclick="moveImage()">이동</button>
        <button id="photoLnR" onclick="lnrImage()">좌우대칭</button>
        <button id="photoUnD" onclick="undImage()">상하대칭</button>
        </div>

        <h4 id="h4_3" onclick="doDisplay3()">히스토그램 ▼[펼치기/닫기]</h4>
        <div id="btn_group3" style="position: relative; left: 800px;">
        <button id="photoStratch" onclick="stratchImage()">히스토그램 스트래칭</button>
        <button id="photoEndIn" onclick="endInImage()">엔드인 탐색</button>
        <button id="photoSmooth" onclick="smoothImage()">평활화</button>
        </div>

        <h4 id="h4_4" onclick="doDisplay4()">화소 영역 처리 ▼[펼치기/닫기]</h4>
        <div id="btn_group4" style="position: relative; left: 780px;">
        <button id="photoEmboss" onclick="embossImage()">엠보싱</button>
        <button id="photoBlurr" onclick="blurrImage()">블러링</button>
        <button id="photoGausian" onclick="gausianImage()">가우시안 필터</button>
        <button id="photoSharp1" onclick="sharpImage1()">샤프닝1</button>
        <button id="photoSharp2" onclick="sharpImage2()">샤프닝2</button>
        </div>

        <h4 id="h4_5" onclick="doDisplay5()">경계선 처리 기능 구현 ▼[펼치기/닫기]</h4>
        <div id="btn_group5" style="position: relative; left: 780px;">
        <button id="photoSharpHigh" onclick="highSharpImage()">고주파필터샤프닝</button>
        <button id="photoSharpLow" onclick="lowSharpImage()">저주파필터샤프닝</button>
        <button id="photoPrewitt" onclick="preWittImage()">Prewitt</button>
        <button id="photoSobel" onclick="sobelImage()">sobel</button>
        </div>
        <hr>
        <hr>
        
        <h4 id="h4_6" onclick="doDisplay6()">색상 ▼[펼치기/닫기]</h4>
        <div id="btn_group6" style="position: relative; left: 600px;">
        <button id="photoChange" onclick="changeSaturation()">채도 변경</button>
        <button id="photoRed" onclick="findRed()">빨간 색상 추출</button>
        <button id="photoOrange" onclick="findOrange()">오렌지 색상 추출</button>
        <button id="photoYello" onclick="findYello()">노란 색상 추출</button>
        <button id="photoGreen" onclick="findGreen()">초록 색상 추출</button>
        <button id="photoBlue" onclick="findBlue()">파란 색상 추출</button>
        <button id="photoPurple" onclick="findPurple()">보라 색상 추출</button>
        </div>
        
        <h4 id="h4_7">결과창</h4>

    <br>

    <canvas id='inCanvas' style=' background-color:rgb(136, 133, 164)'></canvas>
    <canvas id='outCanvas' style=' background-color:rgb(151, 180, 212)'></canvas>
</body>
</html>
​